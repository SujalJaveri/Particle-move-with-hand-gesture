<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Morph - Hand Controlled</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        /* Glassmorphism UI */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 240px;
            padding: 20px;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            z-index: 100;
            color: white;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        h2 { margin: 0 0 15px 0; font-size: 13px; text-transform: uppercase; letter-spacing: 2px; color: #888; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; }

        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 11px; font-weight: 600; color: #aaa; margin-bottom: 6px; }

        /* Buttons */
        .grid-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255,255,255,0.05);
            color: #ccc;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }
        button:hover { background: rgba(255, 255, 255, 0.15); color: #fff; }
        button.active { background: #3b82f6; border-color: #3b82f6; color: white; box-shadow: 0 0 15px rgba(59, 130, 246, 0.4); }

        /* Inputs */
        input[type="color"] { width: 100%; height: 35px; border: none; border-radius: 6px; background: transparent; cursor: pointer; }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: #3b82f6; }

        /* Camera Feedback */
        #cam-status { display: flex; align-items: center; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: #ef4444; margin-right: 8px; box-shadow: 0 0 5px #ef4444; }
        .dot.active { background: #10b981; box-shadow: 0 0 5px #10b981; }
        #status-text { font-size: 11px; color: #888; }

        /* Camera Preview */
        #preview-box {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 120px;
            border-radius: 12px; overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.5);
            z-index: 90;
        }
        #preview-canvas { width: 100%; height: 100%; transform: scaleX(-1); opacity: 0.6; }

        /* Loading Screen */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #050505; z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; font-family: monospace;
            transition: opacity 0.5s;
        }
        .loader-spinner {
            width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%; border-top-color: #3b82f6;
            animation: spin 1s ease-in-out infinite; margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="loader-spinner"></div>
        <div id="loading-text">INITIALIZING SYSTEMS...</div>
        <div style="margin-top:10px; font-size: 12px; color: #666;">Please allow camera access</div>
    </div>

    <div id="ui-panel">
        <h2>Particle Core</h2>
        
        <div class="control-group">
            <label>SHAPE TEMPLATE</label>
            <div class="grid-buttons">
                <button class="shape-btn active" data-shape="heart">Heart</button>
                <button class="shape-btn" data-shape="flower">Flower</button>
                <button class="shape-btn" data-shape="saturn">Saturn</button>
                <button class="shape-btn" data-shape="buddha">Zen</button>
                <button class="shape-btn" data-shape="fireworks" style="grid-column: span 2">Explosion</button>
            </div>
        </div>

        <div class="control-group">
            <label>PARTICLE COLOR</label>
            <input type="color" id="color-input" value="#0088ff">
        </div>

        <div class="control-group">
            <label>GLOW STRENGTH</label>
            <input type="range" id="glow-input" min="0" max="3" step="0.1" value="1.5">
        </div>

        <div id="cam-status">
            <div class="dot" id="status-dot"></div>
            <div id="status-text">Waiting for hands...</div>
        </div>
    </div>

    <video id="input-video" style="display:none"></video>
    <div id="preview-box">
        <canvas id="preview-canvas"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 1. SETUP THREE.JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 60;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Bloom Post-Processing
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.5;
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // --- 2. PARTICLE SYSTEM ---
        const COUNT = 20000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(COUNT * 3);
        const targetPositions = new Float32Array(COUNT * 3);
        const randoms = new Float32Array(COUNT);

        // Initialize points
        for (let i = 0; i < COUNT; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 200;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 200;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
            targetPositions[i * 3] = positions[i * 3];
            randoms[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('random', new THREE.BufferAttribute(randoms, 1));

        // Generate soft circle texture procedurally
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16,16,0,16,16,16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,32,32);
        const texture = new THREE.CanvasTexture(canvas);

        const material = new THREE.PointsMaterial({
            size: 0.7,
            color: new THREE.Color(0x0088ff),
            map: texture,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 3. SHAPE LOGIC ---
        function updateShape(type) {
            const scale = 1.8;
            for(let i=0; i<COUNT; i++) {
                const idx = i*3;
                let x=0, y=0, z=0;

                if(type === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
                    z = (Math.random()-0.5) * 10;
                    x *= scale; y *= scale;
                } else if(type === 'flower') {
                    const theta = Math.random() * Math.PI * 2;
                    const r = 20 + 5 * Math.sin(5 * theta);
                    x = r * Math.cos(theta);
                    y = r * Math.sin(theta);
                    z = (Math.random()-0.5) * 15 + Math.sin(r)*5;
                } else if(type === 'saturn') {
                    if (Math.random() > 0.4) {
                        const theta = Math.random() * Math.PI * 2;
                        const r = 35 + Math.random() * 8;
                        x = r * Math.cos(theta);
                        z = r * Math.sin(theta);
                        y = (Math.random()-0.5);
                    } else {
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2*Math.random()-1);
                        const r = 18;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    }
                } else if(type === 'buddha') {
                    const section = Math.random();
                    const theta = Math.random() * Math.PI * 2;
                    if(section < 0.3) { // Legs
                        const r = 22 * Math.random();
                        x = r * Math.cos(theta) * 1.5;
                        y = -18 + Math.random()*5;
                        z = r * Math.sin(theta);
                    } else if(section < 0.75) { // Torso
                        const r = 12 * Math.random();
                        y = -12 + Math.random() * 24;
                        const taper = (1 - (y+12)/40);
                        x = r * Math.cos(theta) * taper;
                        z = r * Math.sin(theta) * taper;
                    } else { // Head
                        const r = 6;
                        const phi = Math.acos(2*Math.random()-1);
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = 14 + r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    }
                } else if(type === 'fireworks') {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2*Math.random()-1);
                    const r = 55 * Math.cbrt(Math.random());
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }

                targetPositions[idx] = x;
                targetPositions[idx+1] = y;
                targetPositions[idx+2] = z;
            }
        }
        updateShape('heart'); // Initial shape

        // --- 4. UI EVENTS ---
        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                updateShape(e.target.dataset.shape);
            });
        });

        document.getElementById('color-input').addEventListener('input', (e) => {
            material.color.set(e.target.value);
        });

        document.getElementById('glow-input').addEventListener('input', (e) => {
            bloomPass.strength = parseFloat(e.target.value);
        });

        // --- 5. MEDIAPIPE HAND TRACKING ---
        const videoElement = document.getElementById('input-video');
        const previewCanvas = document.getElementById('preview-canvas');
        const previewCtx = previewCanvas.getContext('2d');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');

        let handState = { scale: 1.0, rotX: 0, rotY: 0 };

        function onResults(results) {
            // Draw preview
            previewCanvas.width = videoElement.videoWidth;
            previewCanvas.height = videoElement.videoHeight;
            previewCtx.save();
            previewCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusDot.classList.add('active');
                statusText.innerText = "Tracking Active";

                drawConnectors(previewCtx, results.multiHandLandmarks[0], HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                
                const lm = results.multiHandLandmarks[0];
                
                // Pinch Calculation (Thumb Tip 4 to Index Tip 8)
                const d = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                // Map distance to scale: Close(0.05)=0.1x, Open(0.2)=1.5x
                const targetScale = 0.2 + (Math.max(0, Math.min(1, (d - 0.03)/0.15)) * 1.5);
                
                // Position for rotation (Wrist x/y)
                const rx = (lm[0].y - 0.5) * 2; 
                const ry = (lm[0].x - 0.5) * 3;

                // Smooth update
                handState.scale += (targetScale - handState.scale) * 0.1;
                handState.rotX += (rx - handState.rotX) * 0.1;
                handState.rotY += (ry - handState.rotY) * 0.1;
            } else {
                statusDot.classList.remove('active');
                statusText.innerText = "Show hands...";
                // Reset slightly
                handState.scale += (1.0 - handState.scale) * 0.05;
                handState.rotX *= 0.95;
                handState.rotY *= 0.95;
            }
            previewCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        // --- 6. CAMERA START WITH ERROR HANDLING ---
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });

        cameraUtils.start()
            .then(() => {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').remove(), 500);
            })
            .catch(err => {
                console.error(err);
                document.getElementById('loading-text').innerText = "CAMERA ERROR!";
                document.getElementById('loading-text').style.color = "#ef4444";
                const msg = document.createElement('div');
                msg.style.padding = "20px";
                msg.style.textAlign = "center";
                msg.innerHTML = "Browsers block cameras on local files.<br><br><b>SOLUTION:</b><br>1. Install 'Live Server' extension in VS Code.<br>2. Right-click this file -> 'Open with Live Server'.";
                document.getElementById('loader').appendChild(msg);
            });

        // --- 7. ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const posAttr = particles.geometry.attributes.position;
            const positions = posAttr.array;

            const lerpFactor = 0.08;

            for(let i=0; i<COUNT; i++) {
                const idx = i*3;
                const rnd = randoms[i];

                // Floating noise
                const fx = Math.sin(time*0.5 + rnd*10) * 1.5;
                const fy = Math.cos(time*0.3 + rnd*20) * 1.5;
                const fz = Math.sin(time*0.4 + rnd*30) * 1.5;

                // Move current pos -> target pos
                positions[idx]   += (targetPositions[idx] + fx - positions[idx]) * lerpFactor;
                positions[idx+1] += (targetPositions[idx+1] + fy - positions[idx+1]) * lerpFactor;
                positions[idx+2] += (targetPositions[idx+2] + fz - positions[idx+2]) * lerpFactor;
            }
            posAttr.needsUpdate = true;

            // Apply Hand Transformations
            particles.scale.setScalar(handState.scale);
            particles.rotation.y += 0.002 + (handState.rotY * 0.05);
            particles.rotation.x = (handState.rotX * 0.5);

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
