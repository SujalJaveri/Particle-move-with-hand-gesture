<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Interactive Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }

        /* Modern Glass UI */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 260px;
            padding: 20px;
            background: rgba(10, 10, 10, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            color: #fff;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            transition: opacity 0.3s;
        }

        h1 { margin: 0 0 15px 0; font-size: 14px; text-transform: uppercase; letter-spacing: 2px; color: #888; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
        
        .control-section { margin-bottom: 20px; }
        label { display: block; font-size: 11px; color: #aaa; margin-bottom: 8px; font-weight: 500; }

        /* Grid for buttons */
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        
        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255,255,255,0.05);
            color: #ddd;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        button:hover { background: rgba(255, 255, 255, 0.15); color: #fff; }
        button.active { background: #3b82f6; border-color: #3b82f6; color: white; box-shadow: 0 0 15px rgba(59, 130, 246, 0.4); }

        /* Sliders & Colors */
        input[type="range"] { width: 100%; accent-color: #3b82f6; cursor: pointer; }
        input[type="color"] { width: 100%; height: 40px; border: none; border-radius: 8px; cursor: pointer; background: transparent; }

        /* Status & Preview */
        #status-dot { display: inline-block; width: 8px; height: 8px; background: #f43f5e; border-radius: 50%; margin-right: 6px; }
        #status-text { font-size: 12px; color: #888; vertical-align: middle; }
        
        #preview-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 90;
        }
        #webcam-preview { width: 100%; height: 100%; transform: scaleX(-1); object-fit: cover; opacity: 0.7; }
        
        /* Loading Overlay */
        #loader {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            color: white; z-index: 999; font-family: monospace; letter-spacing: 2px;
            transition: opacity 0.5s;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">INITIALIZING SYSTEM...</div>

    <div id="ui-container">
        <h1>Particle Core</h1>
        
        <div class="control-section">
            <label>VISUALIZATION MODE</label>
            <div class="btn-grid">
                <button class="shape-btn active" data-shape="heart">Heart</button>
                <button class="shape-btn" data-shape="flower">Flower</button>
                <button class="shape-btn" data-shape="saturn">Saturn</button>
                <button class="shape-btn" data-shape="buddha">Zen</button>
                <button class="shape-btn" data-shape="fireworks" style="grid-column: span 2">Explosion</button>
            </div>
        </div>

        <div class="control-section">
            <label>EMISSION COLOR</label>
            <input type="color" id="color-picker" value="#0088ff">
        </div>

        <div class="control-section">
            <label>GLOW INTENSITY</label>
            <input type="range" id="bloom-slider" min="0" max="3" step="0.1" value="1.5">
        </div>

        <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px;">
            <span id="status-dot"></span>
            <span id="status-text">Camera Off</span>
        </div>
    </div>

    <video id="input_video" style="display:none"></video>
    
    <div id="preview-container">
        <canvas id="webcam-preview"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 1. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 60;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
        document.body.appendChild(renderer.domElement);

        // --- 2. POST PROCESSING (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.5; // Initial glow
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 3. PARTICLE SYSTEM ---
        const COUNT = 25000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(COUNT * 3);
        const targetPositions = new Float32Array(COUNT * 3);
        const randoms = new Float32Array(COUNT); // For organic movement
        
        // Init positions
        for(let i=0; i<COUNT; i++) {
            positions[i*3] = (Math.random()-0.5) * 200;
            positions[i*3+1] = (Math.random()-0.5) * 200;
            positions[i*3+2] = (Math.random()-0.5) * 200;
            targetPositions[i*3] = positions[i*3];
            randoms[i] = Math.random();
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('random', new THREE.BufferAttribute(randoms, 1));

        // Create texture manually to avoid loading external image assets
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        context.fillStyle = gradient;
        context.fillRect(0, 0, 32, 32);
        const texture = new THREE.CanvasTexture(canvas);

        const material = new THREE.PointsMaterial({
            size: 0.6,
            color: new THREE.Color(0x0088ff),
            map: texture,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- 4. SHAPE GENERATORS ---
        function setShape(type) {
            const scale = 1.8;
            for(let i=0; i<COUNT; i++) {
                let x=0, y=0, z=0;
                const idx = i*3;

                if (type === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    // Heart equation
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
                    z = (Math.random()-0.5) * 10;
                    // Scale it
                    x *= scale; y *= scale;
                } else if (type === 'flower') {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = (Math.random()-0.5) * Math.PI;
                    const r = 20 + 5 * Math.sin(5 * theta);
                    x = r * Math.cos(theta);
                    y = r * Math.sin(theta);
                    z = (Math.random()-0.5) * 10 + Math.sin(r)*5;
                } else if (type === 'saturn') {
                    // Ring
                    if (Math.random() > 0.3) {
                        const theta = Math.random() * Math.PI * 2;
                        const r = 30 + Math.random() * 10;
                        x = r * Math.cos(theta);
                        z = r * Math.sin(theta);
                        y = (Math.random()-0.5);
                    } else {
                        // Planet
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2*Math.random()-1);
                        const r = 15;
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    }
                } else if (type === 'buddha') {
                    // Abstract meditative stack
                    const section = Math.random();
                    const theta = Math.random() * Math.PI * 2;
                    if(section < 0.3) {
                        // Base
                        const r = 20 * Math.random();
                        x = r * Math.cos(theta) * 1.5;
                        y = -15 + Math.random()*5;
                        z = r * Math.sin(theta);
                    } else if (section < 0.8) {
                        // Body
                        const r = 10 * Math.random();
                        y = -10 + Math.random() * 20;
                        x = r * Math.cos(theta) * (1 - (y+10)/30); // Taper up
                        z = r * Math.sin(theta) * (1 - (y+10)/30);
                    } else {
                        // Head
                        const r = 5; 
                        const phi = Math.acos(2*Math.random()-1);
                        x = r * Math.sin(phi) * Math.cos(theta);
                        y = 12 + r * Math.sin(phi) * Math.sin(theta);
                        z = r * Math.cos(phi);
                    }
                } else if (type === 'fireworks') {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2*Math.random()-1);
                    const r = 50 * Math.cbrt(Math.random());
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }

                targetPositions[idx] = x;
                targetPositions[idx+1] = y;
                targetPositions[idx+2] = z;
            }
        }
        setShape('heart'); // Init

        // --- 5. INTERACTION LOGIC ---
        // UI Listeners
        const btns = document.querySelectorAll('.shape-btn');
        btns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                btns.forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                setShape(e.target.dataset.shape);
            });
        });

        document.getElementById('color-picker').addEventListener('input', (e) => {
            material.color.set(e.target.value);
        });
        
        document.getElementById('bloom-slider').addEventListener('input', (e) => {
            bloomPass.strength = parseFloat(e.target.value);
        });

        // --- 6. MEDIAPIPE LOGIC ---
        const videoElement = document.getElementById('input_video');
        const previewCanvas = document.getElementById('webcam-preview');
        const ctx = previewCanvas.getContext('2d');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');

        let handState = {
            active: false,
            scale: 1.0,
            rotationX: 0,
            rotationY: 0
        };

        function onHandsResults(results) {
            // Draw preview
            previewCanvas.width = videoElement.videoWidth;
            previewCanvas.height = videoElement.videoHeight;
            ctx.save();
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            ctx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // Tracking Active
                statusDot.style.background = "#10b981"; // Green
                statusText.innerText = "Tracking Active";
                handState.active = true;

                // Draw skeleton on preview
                drawConnectors(ctx, results.multiHandLandmarks[0], HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});

                const landmarks = results.multiHandLandmarks[0];

                // 1. PINCH DETECTION (For Scaling)
                // Distance between Thumb(4) and Index(8)
                const p1 = landmarks[4];
                const p2 = landmarks[8];
                const pinchDist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                
                // Map pinch: 0.05 (close) -> 0.2 scale | 0.2 (open) -> 1.5 scale
                const normPinch = Math.max(0, Math.min(1, (pinchDist - 0.02) / 0.15));
                const targetScale = 0.2 + (normPinch * 1.5);
                
                // Smooth damping for scale
                handState.scale += (targetScale - handState.scale) * 0.1;

                // 2. HAND POSITION (For Rotation)
                // Wrist(0) x position: 0 (left) -> 1 (right)
                const wristX = landmarks[0].x;
                const wristY = landmarks[0].y;
                
                // Map 0..1 to -1..1 rotation speed
                const targetRotY = (wristX - 0.5) * 3; 
                const targetRotX = (wristY - 0.5) * 3;

                handState.rotationY += (targetRotY - handState.rotationY) * 0.1;
                handState.rotationX += (targetRotX - handState.rotationX) * 0.1;

            } else {
                // Tracking Lost
                statusDot.style.background = "#f43f5e"; // Red
                statusText.innerText = "Show Hand";
                handState.active = false;
                
                // Return to neutral
                handState.scale += (1.0 - handState.scale) * 0.05;
                handState.rotationY *= 0.95;
                handState.rotationX *= 0.95;
            }
            ctx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onHandsResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start().then(() => {
            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => document.getElementById('loader').remove(), 500);
        });


        // --- 7. ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const posAttr = particleSystem.geometry.attributes.position;
            const posArr = posAttr.array;

            // Physics params
            const lerpSpeed = 0.08;
            
            for(let i=0; i<COUNT; i++) {
                const idx = i*3;
                
                // 1. Morph to shape
                const tx = targetPositions[idx];
                const ty = targetPositions[idx+1];
                const tz = targetPositions[idx+2];
                
                // 2. Add organic float (Noise simulation using sin/cos)
                // Using the 'randoms' buffer to give each particle a unique offset
                const rnd = randoms[i];
                const floatX = Math.sin(time * 0.5 + rnd * 10) * 2;
                const floatY = Math.cos(time * 0.3 + rnd * 20) * 2;
                const floatZ = Math.sin(time * 0.4 + rnd * 30) * 2;

                // Apply movement
                posArr[idx]   += (tx + floatX - posArr[idx]) * lerpSpeed;
                posArr[idx+1] += (ty + floatY - posArr[idx+1]) * lerpSpeed;
                posArr[idx+2] += (tz + floatZ - posArr[idx+2]) * lerpSpeed;
            }
            posAttr.needsUpdate = true;

            // Apply Hand Transforms
            particleSystem.scale.setScalar(handState.scale);
            
            // Auto rotate + Hand influence
            particleSystem.rotation.y += 0.002 + (handState.rotationY * 0.05);
            particleSystem.rotation.x = (handState.rotationX * 0.5);

            // Render with bloom
            composer.render();
        }
        
        // Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
